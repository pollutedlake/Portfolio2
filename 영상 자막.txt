안녕하세요. 경일게임아데미 언리얼 프로그래밍 1기 박상현입니다.
저는 창세기전3 파트1을 WinAPI기반으로 한달간 모작해봤습니다.
게임 시작 시 오프닝영상을 DirectShow를 사용해서 출력하도록 했습니다.
게임 시작 시 DATAMANAGER에서 파일입출력으로 아이템, 파티, 전투스테이지, 대화, 스토리 오브젝트, 씬 순서 데이터들을 읽어옵니다.
이들을 어떻게 사용하는지는 차후 말씀드리겠습니다.
영상길이가 있어 스페이스바를 입력받아 스킵해 넘기도록 하겠습니다.

영상다음에는 타이틀이 있는 타이틀씬이 나오고 Start Game버튼을 누르면 타이틀씬에서 시나리오를 선택하는 씬으로 Fade Out되면서 넘어갑니다.

시나리오 리스트를 모든 시나리오가 있는 이미지에서 클리핑해서 출력하여 스크롤 조작 시 클리핑하는 영역을 조절하여 스크롤을 구현했습니다.
저는 게임 스토리의 한 축을 담당하는 시반 슈미터 에피소드의 마지막 두 시나리오를 모작하였습니다.
처음에는 마지막 챕터가 열리지 않았기 때문에 바로 직전 불사조 챕터를 먼저 들어가보겠습니다.
챕터를 시작하면 선택한 시나리오의 정보를 DATAMANAGER에 저장하고 씬과 배틀씬의 인덱스를 초기화해줍니다.
충격을 받은 주인공 살라딘 앞에서 부하들과 친구들이 처형당하고 그 모습을 본 살라딘이 정신을 차리고 분노하는 장면입니다.

스토리 요약 내용은 프레임이 지날 때마다 이미지를 위에서부터 클리핑하는 영역을 늘리고 아래부분은 길게 늘려 출력하는 방식으로 구현했습니다.

클래스 구조에 대해 말씀드리겠습니다.

DATAMANAGER에 대해 먼저 설명을 드리겠습니다.
DATAMANAGER에서는 게임에 필요한 정보를 파일포인터를 사용한 파일입출력으로 가져오고 진행에 필요한 데이터들을 관리하는 역할을 합니다.
버퍼를 통해 파일을 읽기 때문에 데이터의 전송속도가 빨라 파일포인터를 사용하게 되었습니다.
DATAMANAGER에서 가져오는 데이터에는 아이템, 파티, 전투씬, 대화, 스토리 오브젝트, 씬 순서, 로드한 데이터가 있습니다.
아이템은 아이템의 이름을 key로 아이템의 정보를 value로 갖는 map에 저장합니다.
아이템의 정보에는 이름, 가격, 타입, 스탯이 있습니다.
파티원들의 정보는 파티원이 자주 바뀌지 않고 빠른 접근을 위해 vector로 저장했습니다.
파티원들의 정보에는 이름, 소속, 직업, 스탯, 장비, 스킬이 있습니다.
전투씬 데이터, 스토리 오브젝트, 씬 순서는 시나리오를 key로 하고 씬이 순서대로 진행되기 때문에 데이터를 vector에 담아 value를 갖는 map으로 관리합니다.
전투씬 데이터에는 적들과 오브젝트들의 정보, 전투 시작 시 파티 캐릭터를 배치할 때 필요한 정보, 배경이미지 정보가 있습니다.
적들의 정보에는 위치, 방향, 턴 순서, 타입이 있습니다.
오브젝트들의 정보에는 렌더하는 위치와 정렬할 때 기준으로 삼는 위치, 가로 세로 크기, 인덱스가 있습니다.
스토리 오브젝트에는 스토리 씬에서 움직이지 않고 가만히 있기만 하는 배경 오브젝트들의 타입과 렌더링할 좌표가 담겨있습니다.
대화 정보는 시나리오를 key로 대화 정보를 value로 갖는 map에 저장합니다.
대화 정보에는 말하는 사람과 대화내용, 대화의 타입, 대화 도중 멈추는 타이밍이 있습니다.
파일입출력으로 가져온 데이터 외에도 현재 시나리오와 몇 번째 씬인지 몇 번째 전투씬인지에 대한 정보와 인벤토리를 가지고 있습니다.
아이템, 인벤토리, 파티에 대한 데이터는 상점씬에서 쓰입니다.
로드한 데이터, 전투씬 데이터, 파티 데이터는 전투씬에서 쓰입니다.
씬 순서에 대한 데이터는 SCENEMANAGER에서 씬을 전환할 때 쓰입니다.
대화, 스토리 오브젝트에 대한 데이터는 스토리씬에서 쓰입니다.
각각 어떻게 사용하는지는 각각의 씬에서 설명해드리겠습니다.

스토리씬에서는 DATAMANAGER에서 현재 시나리오를 key값으로 대화를 정보, 스토리 오브젝트의 정보를 찾아 가지고 옵니다. 
캐릭터들 간의 대화는 DATAMANAGER에서 vector에 저장된 대화의 정보를 가지고 진행됩니다.
대화의 정보에는 말하는 대상과 내용, 타입이 있습니다.
말하는 대상을 key값으로 캐릭터의 이미지를 IMAGEMANAGER에서 찾아 렌더합니다.
대화의 타입에 따라 대화가 중앙과 양 옆 출력되는 위치와 전의 대화가 남아있도록 해야하는지 여부를 결정해줍니다.
대화 정보의 순서에 맞게 더빙된 사운드를 출력하게 했고 프레임이 진행될 때마다 버퍼에 매핑하는 글자 수를 늘려줘서 글자가 타이핑되듯한 느낌을 연출했습니다.
사운드는 FMOD를 사용해서 출력했습니다.
FMOD는 개발 기간 단축을 위해 편한 기능을 사용하기 위해서 사용했습니다.
SOUNDMANAGE에서 사운드들을 string 타입의 key값과 FMOD::SOUND class를 value로 갖는 map
getPositoin을 통해 더빙이 끝났는지 확인하여 끝났다는 것을 대화창 우측하단에 알려주며 스페이스키를 입력받아 대화 인덱스를 증가시켜 다음 대화로 넘어가게 했습니다.
만약 대화가 끝나지 않았는데 스페이스키를 입력받으면 사운드를 멈추고 나머지 대화내용을 한번에 출력하여 스킵기능도 구현했습니다.
스토리씬에서 움직이지 않는 오브젝트들은 이미지 종류와 출력하는 위치를 DATAMANAGER에서 파일 입출력으로 읽어 대화 데이터와 함께 같은 StoryScene Class에서 현재 시나리오에 따라 맞는 스토리가 나오도록 확장성을 고려하였습니다.
대화가 멈추는 타이밍 또한 DATAMANAGER에서 대화 정보를 읽을 때 같이 읽어 대화 인덱스가 그 타이밍에 도달하면 대화 진행이 중단되고 상황에 맞는 유닛 움직을 구현했습니다.
조건을 달성하면 다시 대화를 진행하고 대화가 진행됨에 따라 배경이미지가 바뀌면 그에 맞게 Fade In, Fade Out됩니다.

전투씬으로 넘어오면 스토리씬과 마찬가지로 전투스테이지의 데이터를 가지고 적들의 수, 위치, 방향, 순서, 오브젝트들의 위치 등 현재 씬과 맞게 초기화해줬습니다. 
잠시 세이브하고 데이터를 변경해보겠습니다.

전투씬으로 들어오면 전투스테이지의 데이터를 가지고 적들의 수,  위치,  방향, 순서 오브젝트들의 위치 등을 현재 씬과 맞게 초기화해줍니다.
이를 이용해서 하나의 BattleScene class에서 데이터를 조작하여 여러개의 전투씬을 만들 수 있었습니다.
이 병사들의 위치와 방향, 타입을 바꿔줘보겠습니다. 


전투에 들어가면 PARTYMANAGER에서 파티원들의 정보를 읽어 원하는 파티원을 원하는 타일에 출전시키고 제거할 수 있습니다.
자동 배치를 하게 되면 모든 파티원들이 랜덤으로 위치하게 되고 파티원을 공중 탈것에 태우고 내리게 할 수 있습니다.
배치 완료를 누르면 전투에 들어가게 되고 파티원들이 먼저 턴을 잡게 됩니다.

먼저 턴제 시스템이 진행되는 순서에 대해 말씀드리겠습니다.
존재하는 캐릭터들의 상태를 확인해서 죽은 상태라면 제거해주고 턴 순서를 당겨주고 아니라면 업데이트 해줍니다.
적이 전부 없거나 플레이어 캐릭터가 전부 없는 경우로 GameClear와 GameOver를 판단합니다.
모든 캐릭터가 행동중이 아닌 Idle상태이면 현재 캐릭터가 행동을 선택할 수 있습니다. 
한턴에 이동과 액션을 할 수 있으며 현재 캐릭터가 플레이어블 캐릭터라면 이동이 가능한 경우 이동가능한 타일을 이동범위까지 BFS를 통해 탐색합니다.
타일을 탐색할 때는 GetPixel함수를 사용해서 이동가능한 타일인지 여부를 확인하고 캐릭터들의 타일위치를 확인하여 타일의 정보를 알 수 있습니다.
이동가능 한 타일을 클릭하면 A* 알고리즘으로 최단 경로를 찾아 이동합니다.
이동할 때는 선형보간으로 부드럽게 이동하고 한칸 이동할 때마다 이동할 수 있는 범위가 차감되어 이동범위까지 가게 하였습니다.
적이 있는 타일을 클릭하면 공격 가능한 타일에 가는 최단 경로를 찾아 이동하여 공격합니다.
현재 캐릭터가 있는 타일을 클릭하면 액션을 선택할 수 있는 버튼들이 뜨고 스킬을 선택하면 스킬의 타입이 범위기인지 단일기인지 이동기인지 타입에 따라 스킬 사용가능한 타일들을 계산해서 보여주고 클릭을 통해 사용할 수 있습니다.
스킬에 대해서는 이따가 다시 설명드리겠습니다.
우클릭시 다시 되돌아가고 휴식을 누르거나 이동과 액션을 모두 하면 다음 턴으로 넘어가게 됩니다.
이 순서는 비트맵을 통해 시프트 연산으로 구현하였습니다.
현재 턴을 잡은 캐릭터가 적캐릭터라면 가장 가까운 캐릭터를 BFS를 통해 찾아서 공격가능한 범위까지 이동한 후 공격을 하게 됩니다.
현재 캐릭터가 공격중이면 목표 캐릭터에 데미지를 주고 스킬을 사용 중이라면 스킬 이펙트를 렌더합니다.
다음 턴으로 넘어가게 되면 캐릭터들에는 각각 턴속도라는 개념이 존재하고 이 턴속도가 제일 낮으면 턴을 잡는 방식입니다.
따라서 모든 캐릭터들의 턴속도를 현재 캐릭터의 턴속도만큼 차감시켜준다음 현재 캐릭터의 턴속도를 초기화해주고 캐릭터들의 턴속도에 맞게 현재 캐릭터의 턴 순서를 설정해주고 턴 순서가 제일 빠른 캐릭터가 현재 캐릭터가 됩니다.
캐릭터의 턴 순서는 비트셋으로 구현하였습니다.

카메라의 경우 턴이 넘어가면 턴을 잡은 캐릭터로 이동해 현재 턴을 가진 캐릭터를 분명히 알 수 있게 하였습니다.
마우스로 상하좌우 움직일 수 있고 월드좌표계를 카메라의 좌표계로 변환하여 렌더하도록 하였습니다.
다음으로는 캐릭터에 대해 말씀드리겠습니다.
캐릭터의 상태는 IDLE, MOVE, ATTACK, DAMAGED, SKILL, DIE 총 5개로 되어 있고 이를 비트셋으로 확인하고 변경하였습니다.
각 상태와 방향에 맞게 알맞는 모션이 프레임렌더로 렌더링되고 데미지를 입으면 데미지가 출력되게 하였습니다.
죽을 경우에는 알파렌더로 서서히 사라지게 연출하였고 공격시에는 타이밍에 맞게 이펙트나 사운드를 출력하였습니다.
공중 탈것을 탄 캐릭터는 타일을 거쳐서 이동하지 않고 바로 그 타일로 선형보간으로 이동하며 3x3범위 공격을 합니다.
세이브 로드의 경우 퀵 세이브와 퀵 로드는 정해진 파일로 하고 나머지 경우는 세이브 로드 씬으로 이동해서 세이브 슬롯의 파일이 없다면 비어있다는 것을 알려주고
슬롯을 선택해서 세이브를 만들거나 덮어씌우고 그 세이브 파일을 바로 로드해서 세이브 직전 전투씬으로 돌아갑니다.
그럼 현재 시나리오의 정보와 저장 시간 전투씬의 캐릭터들의 데이터를 저장하고 로드할 때는 그 정보들을 읽어옵니다.
시나리오를 클리어하면 타이틀화면으로 돌아가고 다음 시나리오가 열립니다.

이제 형제 시나리오로 들어가겠습니다.
스킬에 대해 설명하자면 스킬에는 범위기 단일기 이동기 타입으로 되어 있고
범위기의 경우 스킬범위내에 적이 있을 경우 단일기의 경우 클릭한 타일에 적이 있을 경우 이동기의 경우 클릭한 타일이 움직일 수 있는 타일일 경우 발동이 됩니다.
스킬이 발동되면 스킬의 순서를 스킬 시전, 사전 준비, 공격, 마무리로 나눠서 각 순서마다 스킬 이펙트를 렌더링하고 배경, 오브젝트, 검은색 배경, 캐릭터, 스킬이펙트 순으로 렌더링합니다.
카메라는 스킬을 쓰는 캐릭터에 업데이트 할 때마다 고정되고 필요에 의하면 카메라의 위치를 잠깐 바꿔줘서 카메라 흔들림을 구현했습니다.

다음으로는 월드맵으로 이동하는데 진입시 마을에 들어가 상점을 이용할 수 있습니다.
아이템의 정보와 파티원들의 정보 착용한 장비의 정보들 역시 게임 시작시 DATAMANAGER에서 파일입출력으로 읽어왔습니다.
상점에서 장비를 사고 팔 수 있으며 이 경우 인벤토리에 들어가고 소지금이 변합니다.
캐릭터의 정보창에서 착용하고 있는 장비를 확인할 수 있고 장비를 바꾸거나 벗을 수 있습니다.
이 때 캐릭터의 스탯도 맞게 변합니다.
마을을 나가서 이동을 하면 다음 씬으로 넘어가고 주인공 살라딘의 연인 셰라자드가 살라딘의 동생 버몬트에게 인질로 잡혀있다가 희생당하는 장면입니다.

빠르게 넘기도록 하겠습니다.

다음은 보스인 동생 버몬트와의 전투 씬입니다.
이 때는 GetPixel을 사용하지 않고 2차원 배열에 타일의 정보를 저장해놓고 바뀔때마다 정보를 업데이트해서 이 정보들을 가지고  구현했습니다.
캐릭터들을 순회하면서 위치 정보를 확인하지 않고 바로 배열에서 값을 읽어와 빠르게 정보를 얻을 수 있었습니다.
1:1전투를 만들기 위해 주위에 있는 병사들을 정리하겠습니다.
보스의 경우 스킬을 쓸 마나가 있으면 스킬을 사용합니다.
전투에서 승리하면 엔딩씬으로 넘어갑니다.

엔딩씬경우는 FMOD의 getPosition과 getLength를 사용해서 자동으로 진행이 됩니다.
뒤에 흘러나오는 배경음악과 싱크를 맞춰 진행됩니다.
엔딩씬이 끝나면 마찬가지로 처음 타이틀화면으로 돌아가게 됩니다.
지금까지 시청해주셔서 감사합니다.

