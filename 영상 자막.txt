안녕하세요. 경일게임아데미 언리얼 프로그래밍 1기 박상현입니다.
저는 창세기전3 파트1을 WinAPI기반으로 한달간 모작해봤습니다.
게임 시작 시 오프닝영상을 DirectShow를 사용해서 출력하도록 했습니다.
또한 DATAMANAGER에서 파일입출력으로 아이템, 파티, 전투스테이지, 대화, 스토리 오브젝트, 씬 순서 데이터들을 읽어옵니다.
이들을 어떻게 사용하는지는 차후 말씀드리겠습니다.
영상길이가 있어 스페이스바를 입력받아 스킵해 넘기도록 하겠습니다.

영상다음에는 타이틀이 있는 타이틀씬이 나오고 Start Game버튼을 누르면 타이틀씬에서 시나리오를 선택하는 씬으로 Fade Out되면서 넘어갑니다.

시나리오 리스트를 모든 시나리오가 있는 이미지에서 클리핑해서 렌더하여 스크롤 조작 시 클리핑하는 영역을 조절하여 스크롤을 구현했습니다.
저는 게임 스토리의 한 축을 담당하는 시반 슈미터 에피소드의 마지막 두 시나리오를 모작하였습니다.
처음에는 마지막 챕터가 열리지 않았기 때문에 바로 직전 불사조 챕터를 먼저 들어가보겠습니다.
챕터를 시작하면 파일입출력을 통해 선택한 시나리오의 정보를 DATAMANAGER에 저장하고 씬과 배틀씬의 인덱스를 초기화해줍니다.
스토리 요약 내용은 이미지 한장을 위에서부터 클리핑하는 영역을 늘리고 아래부분은 길게 늘려 렌더링하는 방식으로 구현했습니다.
충격을 받은 주인공 살라딘 앞에서 부하들과 친구들이 처형당하고 그 모습을 본 살라딘이 정신을 차리고 분노하는 장면입니다.

DATAMANAGER에 대해 먼저 설명을 드리겠습니다.
DATAMANAGER에서는 게임에 필요한 정보를 파일포인터를 사용한 파일입출력으로 가져오고 진행에 필요한 데이터들을 관리하는 역할을 합니다.
이 DATAMANAGER를 싱글톤 패턴을 사용하여 하나의 객체만 생성하고
게임에서 다른 부분에서 해당  객체를 공유하여 사용하게 했습니다.
버퍼를 통해 파일을 읽기 때문에 데이터의 전송속도가 빨라 파일포인터를 사용하게 되었습니다.
(파일 포인터는 플랫폼 독립적인 구조라 어느 플랫폼에서든 동일한 동작을 수행한다는 장점이 있어 사용하게 되었습니다.)
DATAMANAGER에서 가져오는 데이터에는 아이템, 파티, 전투씬, 대화, 스토리 오브젝트, 씬 순서, 로드한 데이터가 있습니다.
아이템은 아이템의 이름을 key값으로, 아이템의 정보를 구조체로 하여 value로 갖는 map에 저장합니다.
아이템의 정보에는 이름, 가격, 타입, 스탯이 있습니다.
파티원들의 정보는 현재 게임에서 바뀌지 않기도 하고 빠른 접근을 위해 구조체로 만들어 vector에 저장했습니다.
파티원들의 정보에는 이름, 소속, 직업, 스탯, 장비, 스킬이 있습니다.
전투씬 데이터, 스토리 오브젝트, 씬 순서는 각각 시나리오를 key값으로 하고 씬이 순서대로 진행되기 때문에 데이터를 vector에 담아 value를 갖는 map으로 만들었습니다.
전투씬 데이터에는 적들과 오브젝트들의 정보, 전투 시작 시 파티원들을 배치할 때 필요한 정보, 배경이미지 정보가 있습니다.
적들의 정보에는 위치, 방향, 턴 순서, 타입이 있습니다.
오브젝트들의 정보에는 렌더하는 위치와 정렬할 때 기준으로 삼는 위치, 가로 세로 크기, 인덱스가 있습니다.
스토리 오브젝트에는 스토리 씬에서 움직이지 않고 가만히 있기만 하는 배경 오브젝트들의 타입과 렌더링할 좌표가 담겨있습니다.
대화 정보는 시나리오를 key값으로 대화 정보를 구조체로 만들어서 value로 갖는 map에 저장합니다.
대화 정보에는 말하는 사람과 대화내용, 대화의 타입, 대화 도중 멈추는 타이밍이 있습니다.
파일입출력으로 가져온 데이터 외에도 현재 시나리오와 몇 번째 씬인지 몇 번째 전투씬인지에 대한 정보와 인벤토리를 가지고 있습니다.
각각의 데이터들이 어디서 사용되는지 말씀드리자면 아이템, 인벤토리, 파티에 대한 데이터는 상점씬에서 쓰입니다.
로드한 데이터, 전투씬 데이터, 파티 데이터는 전투씬에서 쓰일 것이고 씬 순서에 대한 데이터는 SCENEMANAGER에서 쓰입니다.
대화, 스토리 오브젝트에 대한 데이터는 스토리씬에서 쓰이고 
어떻게 사용하는지는 각각의 씬에서 따로 설명해드리겠습니다

지금 나오는 더빙과 같은 모든 사운드는 SOUNDMANAGER에서 관리하며 이 또한 싱글톤으로 만들어 단일 객체 생성과 게임 내 다른 부분들에서 접근이 가능하게 하였습니다.
SOUNDMANAGER는 개발 기간 단축을 위해 외부라이브러리인 FMOD의 기능들을 사용하여 만들었습니다.
게임 시작 시 FMOD::System과 FMOD::Channel들을 만들어 주고 게임에서 사용할 사운드들을 FMOD::Sound 클래스 형태로 map에 저장합니다.
string을 key값으로 map에서 재생시킬 사운드를 찾아 사용하고 있지 않는 FMOD::Channel에서 재생하는 방법으로 사운드를 출력했습니다.
또한, FMOD의 사운드의 총 길이를 알 수 있는 getLength함수나 현재 재생중인 시간을 알 수 있는 getPosition함수를 사용하는 기능도 SOUNDMANAGER에서 사용할 수 있습니다.

SCENEMANAGER도 singleton으로 만들어졌으며 게임에 사용되는 씬들의 이름을 string타입으로 key값으로 만든 map이 있습니다.
SCENEMANAGER에서 현재 씬을 가져와 update하고 render합니다.
특정 조건을 만족하여 씬 이동을 해야할 때는 SCENEMANAGER에서 DATAMANAGER에 있는 현재 시나리오, 씬 인덱스, 전투씬 인덱스로 씬 순서 정보를 확인하여 다음 씬을 알아냅니다.
알아낸 다음 씬을 map에서 찾아 현재 씬을 로딩 씬을 거쳐서 다음 씬으로 교체하고 DATAMANAGER의 씬 인덱스, 전투씬 인덱스를 업데이트 해줍니다. 

DATAMANAGER에서 게임을 불러왔다면 로드한 데이터를 아니라면 파티 데이터와 시나리오, 전투씬 인덱스를 가지고 현재 씬에 맞는 전투씬 데이터를 가져옵니다.
게임을 불러오는 경우는 추후 세이브 로드때 다시 보여드리도록 하겠습니다.
가져온 전투씬 데이터에서 배경이미지 정보를 가지고 배경이미지를 렌더하고 전투 배경 사운드도 재생합니다.
적들과 오브젝트들의 정보로 적들과 오브젝트들을 생성하고 Z Order를 구현하기 위해 vector에 담았습니다.
이 데이터들을 활용해서 하나의 BattleScene class에서 데이터를 조작하여  여러개의 전투씬을 만들 수 있었습니다.
더 구체적으로 이 정보들을 조작하는 모습을 보여드리겠습니다.
전투씬 데이터입니다.
먼저 오브젝트들을 없애고 배경이미지를 바꿔 보겠습니다.
다시 게임을 실행시키고 돌아가면 배경이미지가 바뀌어있습니다.
이번에는 이 적들의 데이터를 바꿔보겠습니다.
적들의 타입과 방향 위치가 바뀌는 것을 확인할 수 있었습니다.

전투를 시작하려면 파티원들을 타일에 배치해 출전시켜야 합니다.
배치할 수 있는 타일의 정보와 파티원들을 배치했을 때 방향은 전투씬데이터에서 확인할 수 있었습니다.
원하는 파티원을 원하는 타일에 배치하게 되면 파티원의 정보를 DATAMANAGER의 파티 데이터에서 가져와 생성하여 vector에 넣었습니다.
배치한 파티원을 출전 취소할 수 있으며 자동 배치를 하게 되면 모든 파티원들이 랜덤으로 위치하게 되고 파티원을 공중 탈것에 태우고 내리게 할 수 있습니다.
배치 완료를 누르면 전투에 들어가게 되고 파티원들이 먼저 턴을 잡게 됩니다.

먼저 턴제 시스템이 진행되는 순서에 대해 말씀드리겠습니다.
존재하는 캐릭터들의 상태를 확인해서 죽은 상태라면 제거해주고 턴 순서를 당겨주고 아니라면 업데이트 해줍니다.
적이 전부 없거나 플레이어 캐릭터가 전부 없는 경우로 GameClear와 GameOver를 판단합니다.
모든 캐릭터가 행동중이 아닌 Idle상태이면 현재 캐릭터가 행동을 선택할 수 있습니다. 
한턴에 이동과 액션을 할 수 있으며 두 행동을 모두 하면 다음 턴으로 넘어갑니다.
현재 캐릭터가 플레이어블 캐릭터이고 이동이 가능한 경우 이동가능한 타일을 이동범위까지 BFS를 통해 탐색하여 보여줍니다.
탐색하는 노드의 수가 많지 않고 검색 속도가 빠르며 최단 경로를 계산할 때 BFS를 활용하므로 코드의 재사용성을 위해 BFS를 사용했습니다.
타일을 탐색할 때는 GetPixel함수를 사용해서 이동가능한 타일인지 여부를 확인하고 캐릭터들의 타일위치를 확인하여 타일의 정보를 알 수 있습니다.
이동가능 한 타일을 클릭하면 A* 알고리즘으로 최단 경로를 찾아 이동합니다.
이동할 때는 선형보간으로 부드럽게 이동하고 한칸 이동할 때마다 이동할 수 있는 범위가 차감되어 이동범위까지 가게 하였습니다.
(출발 위치 X (총 걸린 시간 - 움직인 시간)) / 총 걸린시간 + (도착 위치 X 움직인시간) / 총 걸린시간으로 계산했습니다.
적이 있는 타일을 클릭하면 공격 가능한 타일에 가는 최단 경로를 마찬가지로 A*로 찾아 이동하여 공격합니다.
만약 캐릭터가 공중 탈것을 타고 있다면 지형에 영향을 
받지 않기 때문에 목표 지점까지 선형보간으로 이동합니다.
이동할 때와 공격할 때 캐릭터의 방향은 목표타일과 현재 타일의 x, y의 차이로 계산해서 결정했습니다.
액션의 경우 공격과 현재 캐릭터의 타일을 선택해서 어빌리티(스킬)을 쓰거나 휴식을 클릭해 턴을 마칠 수 있습니다.
어빌리티(스킬)에 대해서는 이따가 다시 설명해드리겠습니다.
현재 턴을 잡은 캐릭터가 적캐릭터라면 가장 가까운 캐릭터를 BFS를 통해 찾아서 공격가능한 범위까지 이동한 후 공격을 하게 됩니다.
현재 캐릭터가 공격중이면 목표 캐릭터에 데미지를 주는데 만약 공중탈것을 탄 상태라면 목표 타일을 중심으로 3x3범위의 캐릭터들에게 데미지를 주고 스킬을 사용 중이라면 스킬 이펙트를 렌더합니다.
그렇게 현재 턴의 캐릭터가 모든 행동을 마치고 턴을 넘기게 되면 다음 턴을 잡을 캐릭터를 계산합니다.
캐릭터들에는 각각 턴속도라는 개념이 존재하고 이 턴속도가 제일 낮으면 턴을 잡는 방식입니다.
따라서 모든 캐릭터들의 턴속도를 현재 캐릭터의 턴속도만큼 차감시켜준다음 현재 캐릭터의 턴속도를 초기화해주고 턴속도에 맞게 정렬해 턴 순서를 결정하게 됩니다.
캐릭터의 턴 순서는 비트셋으로 구현하여 메모리 사용량과 시프트 연산을 통해 쉽게 계산할 수 있었습니다.

게임 내의 캐릭터와 오브젝트들을 렌더하는 순서는 먼저 캐릭터들의 위치에 그림자를 렌더합니다.
비행 탈것의 그림자의 경우 비행 탈것을 탄 캐릭터의 프레임을 가져와 싱크를 맞췄습니다.
그 후 캐릭터와 오브젝트가 들어간 vector를 y좌표를 기준으로 정렬합니다.
정렬된 순서대로 vector를 순회하면 캐릭터와 오브젝트들을 렌더하여 Z-Order를 구현했습니다.

카메라는 방향키나 마우스로 이동할 수 있으며 렌더할 때 월드좌표계에서 카메라 좌표계로 변환하여 렌더하도록 하였습니다.
좌표계 변환은 스크린의 중점 - (카메라의 월드 좌표 - 렌더할 대상의 월드 좌표)로 계산하였습니다.
턴이 넘어갈 때 카메라를 턴을 잡은 캐릭터로 이동시켜 현재 턴을 가진 캐릭터를 알기 쉽게 하였습니다.

캐릭터들은 Character class를 상속받은 Player와 Enemy로 나뉩니다.
캐릭터의 상태는 IDLE, MOVE, ATTACK, DAMAGED, SKILL, DIE가 있고 이를 비트셋으로 확인하고 변경하였습니다.
각 상태와 방향에 맞게 알맞는 모션이 프레임렌더로 렌더링되고 데미지를 입으면 데미지가 출력되게 하였습니다.
죽을 경우에는 알파렌더로 서서히 사라지게 연출하였고 공격시에는 타이밍에 맞게 이펙트나 사운드를 출력하였습니다.
Player와 Enemy 둘다 각각 캐릭터 종류에 따라 이미지와 사운드만 다를 뿐 하는 동작은 같기 때문에 더 분류하지 않았습니다.
캐릭터의 종류에 따라 알맞은 이미지와 효과 사운드를 출력하였습니다.

구현한 A*에 대해 말씀드리겠습니다.
휴리스틱 값은 대각선으로 이동하지 않기 때문에 그 노드와 목적지 노드의 x, y차이의 합으로 계산했습니다.
그래프의 모든 정점의 비용과 부모노드를 나올 수 없는 값으로 초기화하고 이를 이용해 닫힌목록인지 열린목록인지 판단했습니다.
현재 노드를 기준으로 모든 방향의 노드에 대한 비용을 계산하고 그 노드들의 비용과 부모노드를 업데이트해서 닫힌목록에 넣습니다.
그 노드들을 비용이 적은 순으로 정렬하는 우선순위 큐에 넣어서 다음 노드를 결정할 수 있습니다.
이를 목적지 노드에 도달할때까지 반복한다음 목적지 노드에 도달하면 부모노드를 역추적하면서 vector에 넣어 최단경로를 찾을 수 있었습니다.
시나리오를 클리어하면 시나리오를 선택하는 씬으로 되돌아오고 다음 시나리오가 해금됩니다.
이제 형제 시나리오로 들어가겠습니다. 형제 시나리오는 월드맵->상점->전투->스토리->보스전투->엔딩으로 구성됩니다.
월드맵은 마우스와 방향키로 카메라를 이동하면서 둘러볼 수 있습니다.
진입 버튼을 클릭하면 마을에 들어가 상점을 이용할 수 있습니다.
상점에서는 아이템의 정보와 파티원들의 정보, 소지금, 인벤토리를 DATAMANAGER에서 가져와 사용합니다.
파티원 클릭 시 가져온 파티 데이터로 이름, 소속, 직업, 스탯, 장비를 볼 수 있습니다.
기존 장착하고 있던 무기들을 팔고 새 무기들을 사서 장착해보겠습니다. 장비를 해제하면 인벤토리에 들어가게 됩니다.
DATAMANAGER의 아이템 정보에서 이름과 가격, 인벤토리에 있는 아이템의 개수를 보여줍니다. 밑에는 현재 소지금을 가져와 보여줍니다.
상점에서 아이템을 구매하거나 판매하면 인벤토리에 들어오고 빠지게 되며 이에 따라 소지금도 변하게 됩니다.
인벤토리는 아이템 이름을 key값으로 아이템 정보와 개수를 pair로 묶어 value로 관리합니다.
구매하면 인벤토리의 아이템 개수를 증가시키고 없다면 insert하고 팔 때는 반대로 개수를 감소시키고 개수가 0이 되면 erase하는 방식입니다.
캐릭터에게 장비를 장착시키면 파티원들의 장비 정보와 인벤토리의 아이템 정보가 상호작용합니다.
이 때 캐릭터의 스탯도 변하는 것을 확인할 수 있습니다. 현재 무기를 교체하므로 Str 스탯이 변하는 것을 볼 수 있습니다.
아이템은 타입이 있어 타입이 다르면 서로 간섭하지 않고 교체 시 변하는 스탯도 다르게 했습니다.
예를 들면 인벤토리에 무기만 있으면 신발과 교체할 수 없고 신발을 교체하면 Speed 스탯에 영향이 가는 방식입니다.
마을을 나가면 월드맵으로 돌아가게 되며 이동 버튼을 누르고 목적지를 누르면 다음 씬으로 이동하게 됩니다.

세이브 로드의 경우 퀵 세이브와 퀵 로드는 정해진 파일로 하고 나머지 경우는 세이브 로드 씬으로 이동해서 세이브 슬롯의 파일이 없다면 비어있다는 것을 알려주고
슬롯을 선택해서 세이브를 만들거나 덮어씌우고 그 세이브 파일을 바로 로드해서 세이브 직전 전투씬으로 돌아갑니다.
그럼 현재 시나리오의 정보와 저장 시간 전투씬의 캐릭터들의 데이터를 저장하고 로드할 때는 그 정보들을 읽어옵니다.
스킬에 대해 설명하자면 스킬에는 범위기 단일기 이동기 타입으로 되어 있고
범위기의 경우 스킬범위내에 적이 있을 경우 단일기의 경우 클릭한 타일에 적이 있을 경우 이동기의 경우 클릭한 타일이 움직일 수 있는 타일일 경우 발동이 됩니다.
스킬을 사용하게 되면 화면이 어두워지며 카메라가 스킬을 사용한 캐릭터에 고정됩니다.
스킬 범위 내의 캐릭터들과 스킬을 쓴 캐릭터,  스킬이름을 인자로 넘겨주며 스킬이름에 따라 다른 이펙트를 렌더링하고 스킬 시전 캐릭터가 다른 행동을 합니다.
'혈랑마혼'의 경우 늑대를 알파프레임렌더로 희미해져가며 이동시킵니다.
그 다음 캐릭터가 움직일 때 캐릭터 위치부터 시전위치까지 같은 이미지를 알파렌더로 점점 희미하게 렌더링해서 잔상을 연출했습니다.
캐릭터가 이동하려는 타일까지의 3줄에 있는 적들에게 번개가 떨어지고 데미지를 입게 했으며
캐릭터가 이동하려는 거리의 절반을 이동했을 때부터 양옆에서 분신이 따라와 분신이 도착하면 스킬이 끝납니다.
'천지파열무'의 경우 스킬 시전 시 각각의 타일이 갈라지는 모양을 3종류 중 랜덤으로 골라 2차원배열에 저장합니다.
이 후 땅에서 빛이 나오거나 폭발하거나 땅이 원상태로 돌아가는 이미지를 갈라지는 모양에 맞게 렌더링했습니다.
스킬 시전 후 프레임이 증가하면서 2차원배열을 순회하며 알맞는 이펙트를 타이밍 맞게 렌더링했고
갈라진 땅이 폭발할 때 나오는 돌들은 서로 다르게 회전하는 것처럼 보이기 위해 인덱스에 소수를 곱하고 나머지 연산하여 처음 모양을 다르게 했으며 나타나는 위치 또한 랜덤으로 계산했습니다.
그 후 인자로 넘겨받은 스킬범위 내의 캐릭터들을 순회하며 적의 위치에 
폭발이펙트를 렌더링하고 데미지를 주게 하였습니다.
'천지파열무'사용 시 카메라의 흔들림은 카메라가 스킬 시전하는 캐릭터에 고정되어 있는 상태에서 랜덤으로 위치를 조금씩 변경하여 구현했습니다.
스킬을 시전하면 기존 렌더링하는 순서를 사용하지 않고 배경, 오브젝트, 검은색 배경, 캐릭터, 스킬이펙트 순으로 렌더링해서 캐릭터가 오브젝트에 가려지지 않고 잘 보이게 했습니다.
'천지파열무'를 사용하여 적들을 마무리하고 넘어가겠습니다.
천지파열무

주인공 살라딘의 연인 셰라자드가 살라딘의 동생 버몬트에게 인질로 잡혀있다가 희생당하는 장면입니다.
스토리씬에서는 DATAMANAGER에서 현재 시나리오를 key값으로 대화를 정보, 스토리 오브젝트의 정보를 찾아 가지고 옵니다. 
캐릭터들 간의 대화는 DATAMANAGER에서 vector에 저장된 대화의 정보를 가지고 진행됩니다.
대화의 정보에는 말하는 대상과 내용, 타입이 있습니다.
말하는 대상을 key값으로 캐릭터의 이미지를 IMAGEMANAGER에서 찾아 렌더합니다.
대화의 타입에 따라 대화가 중앙과 양 옆 출력되는 위치와 전의 대화가 남아있도록 해야하는지 여부를 결정해줍니다.
대화 정보의 순서에 맞게 더빙된 사운드를 출력하게 했고 프레임이 진행될 때마다 버퍼에 매핑하는 글자 수를 늘려줘서 글자가 타이핑되듯한 느낌을 연출했습니다.
FMOD의 getPosition함수를 통해 더빙이 끝났는지 확인하여 끝났다는 것을 대화창 우측하단에 알려줍니다. 
스페이스키를 입력받아 대화 인덱스를 증가시켜 다음 대화로 넘어가게 했습니다.
만약 대화가 끝나지 않았는데 스페이스키를 입력받으면 사운드를 멈추고 나머지 대화내용을 한번에 출력하여 스킵기능도 구현했습니다.
스토리씬에서 움직이지 않는 오브젝트들은 이미지 종류와 출력하는 위치를 DATAMANAGER에서 파일 입출력으로 읽어 대화 데이터와 함께 같은 StoryScene Class에서 현재 시나리오에 따라 맞는 스토리가 나오도록 확장성을 고려하였습니다.
대화가 멈추는 타이밍 또한 DATAMANAGER에서 대화 정보를 읽을 때 같이 읽어 대화 인덱스가 그 타이밍에 도달하면 대화 진행이 중단되고 상황에 맞는 유닛 움직을 구현했습니다.
조건을 달성하면 다시 대화를 진행하고 대화가 진행됨에 따라 배경이미지가 바뀌면 그에 맞게 Fade In, Fade Out됩니다.

보스인 동생 버몬트와의 전투입니다.
천지파열무를 사용해서 병사들을 정리하는 모습을 실제 게임 영상과 비교해서 보여드리겠습니다.
천지파열무
보스턴이 되었을 때 스킬을 쓸 수 있는 마나가 되면 스킬을 사용합니다.
버몬트의 스킬로는 설화난영참을 골랐습니다.
스킬 대상 위치 위에서 냉기가 반복하며 반원을 그리면서 내려와 쌓이는 모습은 삼각함수를 이용해 동선을 구현했습니다.
추적하는 대상과의 각도를 atan로 계산하여 방향을 구하고 대상과의 거리의 .1배 움직이면 턴 순서가 빠른 순으로 다음 대상을 추적하게 했습니다.
버몬트를 따라다니는 파란색 구는 배열에 넣어 크기가 점점 작게 렌더하고 첫번째 구만 버몬트를 따라다니고 그 뒤는 바로 직전 구를 따라가게 했습니다.
또한 작고 하얀 원을 y값은 계속 증가하되 x값은 랜덤으로 좌우로 이동해서 눈이 내리는 듯한 효과를 연출했습니다.
이 전투씬의 경우 타일의 정보를 2차원 배열에 저장해놓고 업데이트 될 때마다 2차원 배열의 값을 바꿔주는 방식으로 구현했습니다.
따라서 타일의 정보를 확인할 때 GetPixel함수와 캐릭터를 순회하여 위치 정보를 확인하지 않고 바로 배열에 접근해서 빠르게 알아올 수 있었습니다.
하지만 캐릭터들의 위치가 바뀔 때마다 배열의 값을 업데이트 해줘야 하고 이를 저장하고 있어야 하는 별도의 메모리 용량이 필요합니다.
전투에서 승리하면 엔딩씬으로 넘어갑니다.
단일 스킬인 풍아열공참으로 마무리하고 넘어가겠습니다.

엔딩씬입니다.
살라딘이 동생 버몬트에게 둘만의 추억을 상기시켜 자신의 정체를 알리는 장면입니다.
엔딩씬 같은 경우는 배경음악과 싱크를 맞춰 진행하기 위해 FMOD의 getPosition함수와 getLength 함수를 사용하여 자동으로 진행이 됩니다.
엔딩 씬인만큼 이번 한 달 동안 포트폴리오를 진행하면서 느낀점을 이야기하면서 마치도록 하겠습니다.
일단 포트폴리오 시작전에 생각했던 완성도까지 달성한거 같아 뿌듯하고 만족합니다.
작업을 하면서도 어떻게 해야 할지 고민해보고 생각한대로 시도해보고 안되면 다시 고민해서 해결하는 과정이 즐겁고 되는 것을 보면서 보람찼습니다.
실제 게임을 할 때 만들어본 경험이 없다보니 플레이할 때는 아무생각 없이 지나쳤던 사소한 것들이 생각보다 간단하지 않고 작업량도 사소하지 않다는 것을 느꼈습니다.
또한, 이런 작은 디테일들이 보이기에는 사소해보이고 만들기 귀찮아도 하나하나 만들다보면 쌓여서 게임의 완성도를 높인다는 것을 알게 되었습니다.
프로젝트를 진행하면서 배운 점도 많았습니다.
턴 시스템을 구축할 때 비트셋을 사용하고 getPixel로 맵의 정보를 읽어오는 방법, FMOD나 DirestShow같은 라이브러리, 포토샵이나 영상편집 등 새롭게 접한 것들도 있었고
턴 시스템을 구축할 때 비트셋을 사용하고 getPixel로 맵의 정보를 읽어오는 방법, FMOD나 DirestShow같은 라이브러리, 포토샵이나 영상편집 등 새롭게 접한 것들도 있었고
bfs나 a*알고리즘, 선형보간, 파일입출력 등 어느 정도 알고 있었던 것들도 다시 확인해보고 게임에 접목시키는 것도 고민해보게 되었습니다.
그중에 크게 배운점은 설계할 때 확장성을 고려해서 설계를 해야 한다는 것이었습니다.
처음 설계할 때 제가 생각한 분량이 있고 그만큼만 만들거니까 확장성을 고려하지 않았었습니다.
그러나 중간에 계획이 변경되면서 게임의 볼륨을 추가로 확장하게 되었습니다.
이는 처음 설계할 때 고려하지 않았던 부분이라 추가된 볼륨에 전에 만들었던 구조를 재사용하는데 사족이 많이 붙어 애를 먹었습니다.
이에 다음부터는 설계할 때 확장성을 고려해야 개발하는데 편하고 기간 단축에 큰 도움이 되겠다는 것을 느꼈습니다.
개발할 때 뿐만 아니라 차후 있을 업데이트나 유지보수를 생각하고 만들어야 좋은 개발이라고 배울 수 있었습니다.
이 확장성 부분과 제가 만든 게임을 남들이 해주고 좋아해주었던 일이 제일 기억에 남습니다.
제가 더 좋은 실력이 있었다면 더 많이 구현하고 더 깔끔하고 효율적인 방법으로 하지 않았을까 하는 아쉬움은 있지만 한달동안 최선을 다했기 때문에 후회는 없습니다.
앞으로 열심히 갈고 닦아 더 좋은 모습 보여드리도록 하겠습니다.
